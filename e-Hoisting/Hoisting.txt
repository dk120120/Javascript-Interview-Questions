// hat is hoisting in Javascript?

When the JavaScript engine executes the JavaScript code, it creates the global execution context. The global execution context has two phases:
-Creation
-Execution

During the creation phase, the JavaScript engine moves the variable and function declarations to the top of your code/script/scope. This is known as hoisting in JavaScript.
Hoisting in JavaScript is a behavior in which a function or a variable can be used before declaration.

Features of Hoisting:
-In JavaScript, Hoisting is the default behavior of moving all the declarations at the top of the scope before code execution. Basically, it gives us an advantage that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local. 
-It allows us to call functions before even writing them in our code. 
-JavaScript allocates memory for all variables and functions defined in the program before execution
-Note: JavaScript only hoists declarations, not initializations.


1. Variable hoisting in JavaScript
Variable hoisting means the JavaScript engine moves the variable declarations to the top of the script.

i) Var Keyword
For example, the following example declares the counter variable and initialize its value to 1:

console.log(counter); // 👉 undefined
var counter = 1;

In this example, we reference the "counter" variable before the declaration.
However, the first line of code doesn’t cause an error. The reason is that the JavaScript engine moves the variable declaration to the top of the script.

Technically, the code looks like the following in the execution phase:

var counter;
console.log(counter); // 👉 undefined
counter = 1;

During the creation phase of the global execution context, the JavaScript engine places the variable "counter" in the memory and initializes its value to undefined

ii) let and const keyword
Variables declared with let and const are hoisted but not initialized with a default value. Accessing a let or const variable before it's declared will result in a ReferenceError:

console.log(foo); // Uncaught ReferenceError: Cannot access 'foo' before initialization
let foo = 'bar';  // Same behavior for variables declared with const


iii) The temporal dead zone
The reason that we get a reference error when we try to access a let or const variable before its declaration is because of the temporal dead zone (TDZ).
The TDZ starts at the beginning of the variable's enclosing scope and ends when it is declared. Accessing the variable in this TDZ throws a ReferenceError.

2. Function hoisting

i) Normal Functions
Like variables, the JavaScript engine also hoists the function declarations. This means that the JavaScript engine also moves the function declarations to the top of the script. For example:

let x = 20,
  y = 10;

let result = add(x, y); 
console.log(result); // 👉 30

function add(a, b) {
  return a + b;
}

Output:
30

ii) Functions Expressions

The following example changes the add from a regular function to a function expression:

let x = 20,
    y = 10;

let result = add(x,y); // ❌ Uncaught ReferenceError: add is not defined
console.log(result);

let add = function(x, y) {
    return x + y;
}

If you execute the code, the following error will occur:

Uncaught ReferenceError: add is not defined

During the creation phase of the global execution context, the JavaScript engine creates the add variable in the memory and initializes its value to undefined.

When executing the following code, the add is undefined, hence, it isn’t a function:

let result = add(x,y);

The add variable is assigned to an anonymous function only during the execution phase of the global execution context.

ii) Arrow Functions

The following example changes the add function expression to the arrow function:

let x = 20,
    y = 10;

let result = add(x,y); // ❌ Uncaught ReferenceError: add is not defined
console.log(result);

let add = (x, y) => x + y; 

The code also issues the same error as the function expression example because arrow functions are syntactic sugar for defining function expressions.

Uncaught ReferenceError: add is not defined

Similar to the functions expressions, arrow functions are not hoisted.